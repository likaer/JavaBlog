---
title: 高性能Mysql读后感-Schema与数据类型优化
date: 2019-07-18 19:07:55
tags: Mysql
---

# 如何定义合适的数据类型

## 1. 更小的通常更好

- 降低了存储空间，减少CPU和内存的开销
- 保证没有低估数据范围，扩容是一个耗时和痛苦的操作

## 2. 简单的更好

- 整型比字符串代价更低
- 例：用整型存储IP地址，用Date而不是字符串来存储日期和时间

## 3. 尽量避免NULL

- 可为NULL的列会占用更多的存储空间，在Mysql中需要很多特殊处理
- 可为NULL的列会使索引更加复杂，甚至可能导致固定大小的索引变成可大可小
- 将可为NULL改为NOT NULL对性能的提升比较小，所以除非确定这会导致问题，
  否则没必要去专门修改这种情况

## 4. 整数类型

- TINYINT(8) < SMALLINT(16) < MEDIUMINT(24) < INT(32) < BIGINT(64)
- 整数类型有UNSIGNED表示不允许负数，两者的存储空间和性能相同
- 整数类型指定宽度不会限制值的合法范围，只是单纯的用于展示
- 超过BIGINT长度的整数可以用实数类型或者字符串类型来存储

## 5. 实数类型

- 实数类型指包含小数部分的数字，单精度浮点数(FLOAT)和双精度浮点数(DOUBLE),定点类型(DECIMAL).
- FLOAT占用4个字节，DOUBLE占用8个字节, 比FLOAT有更高的精度和范围
- 浮点数是用二进制数据的科学计数法表示的，因此不能精确的表示实数.
- MYSQL5.0及以上的版本，DECIMAL类型最多允许65个数字.
- 在对小数进行精确计算和存储时，应尽量使用DECIMAL---如财务数据，交易数据.
- 在数据量较大的时候可以考虑使用BIGINT存储.

## 6. 字符串类型

- VARCHAR和CHAR是两种最主要的字符串类型
- BLOB和TEXT则是为存储大数据而设计的字符串

### VARCHAR：
- VARCHAR存储可变长字符串，并使用1或2个额外字节记录字符串长度，比定长字符串更节省空间
- 由于UPDATE可能使得行变的比原来长，导致需要做额外的工作。
- 5.0及以上的版本会存储VARCHAR末尾空格
- 使用VARCHAR的情况通常如下
     + 字符串列的最大长度比平均长度大很多，即字符串长度分布极不均匀
     + 较少的列更新频率
     + 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数存储

### CHAR：
- CHAR存储定长字符串，因此不容易产生碎片
- 存储CHAR类型时，Mysql会删除所有的末尾空格
- 使用CHAR的情况通常如下
    + 字符串长度较短
    + 较高的列更新频率
    + CHAR(1)比VARCHAR(1)在存储空间上更有效

## 7. 日期和时间类型

- Mysql提供DATETIME和TIMESTAMP两种相似的日期类型
- DATETIME能保存大范围的值，从1001年到9999年, 精度为秒, 与时区无关
- TIMESTAMP只能保存1970年11月1号到2038年的日期, 时区相关, 默认NOT NULL
- TIMESTAMP使用4个字节存储，DATETIME使用8个字节存储
- 如果要存储微秒级别的时间戳，建议使用BIGINT类型存储

# 高性能索引策略

## 1. 使用独立的列来进行比较

所谓独立的列，是指索引列不能是表达式的一部分，也不能是函数的参数，否则MySQL就不会使用索引

```
##不能命中columnA索引
select * from tableA where cloumnA + 1 < 100;
##可以命中columnA索引
select * from tableA where cloumnA < 100 - 1;

##不能命中columnB索引
select * from tableA where FROM_UNIXTIME(columnB) = '2016-04-20 20:00:00';
##可以命中columnB索引
select * from tableA where columnB = unix_timestamp('2016-04-20 20:00:00');
```

## 2. 使用索引扫描来做排序

只有当索引的列顺序和ORDER BY的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果进行排序


## 3. 冗余和重复索引

1. 如果已经创建了(columnA,columnB)索引，再创建columnA索引就是冗余索引，因为前者完全可以当后者使用
2. 已有A索引的情况下，应该将索引扩展到(A,B)而不是建新的索引
3. 过多的索引会导致插入速度的下降
4. 有的索引从来没有使用过

<font color="red">注：查询INFORMATION_SCHEMA库索引使用频率或使用Percona Toolkit工具可以查询这一类的索引</font>

## 4. 多列索引

- 将选择性最高的列放到索引的最前列
- 寻找searchable arguments来使用区分度更加明显的列
- 保证查询性能的情况下，尽量少的建立索引

