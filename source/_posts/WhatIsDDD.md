---
title: WhatIsDDD
date: 2021-03-01 14:40:55
tags:
---


# DDD(Domain-Driven-Design)

领域驱动设计，是一种设计概念，用于在复杂业务场景下，构建满足业务诉求下可持续发展的业务系统。



传统架构下存在的问题：

- 业务模型间依赖性与业务领域边界定义不清晰，并且随着需求迭代升级，系统的业务抽象模型容易畸形扭曲
- 业务领域专家与开发之间存在代沟，难以在业务本质和代码实现上达成共识



1. 产出通用、共享的团队模型语言，基于模型语言交流，交流越频繁，越有利于大家对模型的认知达成一致

2. 搭建领域模型，这有利于开发不会基于功能去编写代码

3. 使用分层架构使领域模型具有内聚性，且只依赖于下层



# 后端服务体系架构

## 生态化分布式服务体系架构

### 基础组件

1. RocketMQ
2. Druid
3. 分布式事务
   - TCC模式
   - 消息模式
   - XA事务
   - 本地消息表
4. Dubbo
5. DDD框架
   - COLA架构
   - 集成发布系统
6. XXL-JOB
7. 日志服务
   - 日志打点
   - 全链路追踪埋点

共享服务域

1. 教师域
2. 课程域
   - 课程记录
   - 教材
3. 教务域
   - 依赖教师域
   - 依赖课程域

### 基础服务

1. 消息服务中心
   - 钉钉
   - 短信
   - App推送
2. CRM中心
3. 用户中心
   - 用户统一登录体系
   - 用户权限管理体系
4. 大数据平台(Spark)
5. 发布系统





#消息中间件

RocketMQ业务支持

- 定义消息的groupId，支持消息的分发
- 支持事务消息，顺序消息

# 分布式事务解决方案

## TCC模式

TCC 模式，不依赖于底层数据资源的事务支持：

- 一阶段 try 行为：调用 **自定义** 的 try 逻辑。
- 二阶段 commit 行为：调用 **自定义** 的 commit 逻辑。
- 二阶段 rollback 行为：调用 **自定义** 的 rollback 逻辑。

所谓 TCC 模式，是指支持把 **自定义** 的分支事务纳入到全局事务的管理中

## SAGA模式

Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现

***SAGA相比较TCC少了Try阶段，在思想方面类似于2PC和3PC的区别***



## XA模式

XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准

XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务



## 本地消息表

- 对业务请求实现本地异步化，标记业务状态为执行中
- 通过重试解决网络问题，接口支持幂等
- 通过业务回滚方法解决消息消费失败的场景
- 本地消息表告警机制

# 分布式基础理论

## 2PC

2PC(tow phase commit)两阶段提交。

所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。

我们将提议的节点称为协调者(coordinator)，其他参与决议节点称为参与者(participants, 或cohorts)。

## 3PC

三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。

与两阶段提交不同的是，三阶段提交有两个改动点。

- 引入超时机制。同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

 也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有`CanCommit`、`PreCommit`、`DoCommit`三个阶段。

## CAP

[一致性](https://baike.baidu.com/item/一致性/9840083)（Consistency）、[可用性](https://baike.baidu.com/item/可用性/109628)（Availability）、[分区容错性](https://baike.baidu.com/item/分区容错性/23734073)（Partition tolerance）。CAP 原则指的是，这三个[要素](https://baike.baidu.com/item/要素/5261200)最多只能同时实现两点，不可能三者兼顾。

![img](images/cap.png)

**CA without P：**如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。

**CP without A：**如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。

 **AP wihtout C：**要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。

## BASE

基本可用（Basically Available）软状态（Soft State）最终一致性（Eventually Consistent）

即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）

## Paxos

选举制算法，保证分布式系统数据的强一致性



# 数据库理论

## 读写分离

## 分布式数据库解决方案

用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing) 解决方案。TiDB 适合高可用、强一致要求较高、数据规模较大等各种应用场景



# Redis



## 基础知识

默认有16个数据库

String、List、Set、Hash、Zset、BitMaps(位图)、Hyperloglogs、Geospatial(地理)



**Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。**





**缓存雪崩**

缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

**解决办法：**

事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。

事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉

事后：利用 redis 持久化机制保存的数据尽快恢复缓存

**缓存穿透**

请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

常用解决方案：布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。