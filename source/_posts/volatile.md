---
title: volatile
date: 2020-12-25 10:57:53
tags:
---


# volatile如何保证有序性和可见性

volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）

对 volatile 变量的写指令后会加入写屏障
对 volatile 变量的读指令前会加入读屏障

## 可见性

![Maven repo](images/volatile1.png)

如果线程t1频繁的访问一个全局变量run，JIT(即时编译器)为了提高效率会将run变量从主存加载到CPU缓存中，此时主线程对run变量所做的修改不会立即被t1线程感知到,这导致了t1线程的可见性问题.


注：JIT主要用于"热点代码"的编译为机器码，并进行优化

## 有序性

```java
//由于flag对i没有依赖，所以flag的执行可能会在i之前进行
int i = 0;
boolean flag = false;
```

- 单核CPU在位级和指令级两个层次上都能够并行地使用内置的晶体管资源(流水线化指令)
- 基于此，JIT在不影响当前线程正确性的情况下，可能调整指令的顺序来优化性能，我们把这种现象称为指令重排
- 在多线程场景下，指令重排可能会影响到最终结果


## 如何保证可见性

- 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中
- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据


## 如何保证有序性

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

